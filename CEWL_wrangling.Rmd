---
title: "Climate Water Loss Experiment - CEWL Data Wrangling"
author: "Savannah Weaver"
date: "2021"
output: pdf_document
toc: TRUE
---


# Packages

```{r setup, include = TRUE}
`%nin%` = Negate(`%in%`)
if (!require("tidyverse")) install.packages("tidyverse")
library("tidyverse") # workflow and plots
```


# Background and Goals

This CEWL (cutaneous evaporative water loss) data was collected June - August using a handheld evaporimeter (BioX AquFlux) on adult male *Sceloporus occidentalis*. Measurements were taken on the dorsum in 5 technical replicates before and after 8 days in different climate treatments. In this R script, I bring all the data files into one dataframe, check the distribution of replicates, omit outliers, and average remaining replicates. The final values will be more precise and accurate estimates of the true CEWL, and those values will be used in the capture_analysis and experiment_analysis R script files. Please refer to **doi:** for the published scientific journal article and full details.


# Load Data

1. Compile a list of the filenames I need to read-in.

```{r}
# make a list of file names of all data to load in
filenames <- list.files(path = "data/CEWL", pattern = "\\.csv$")
```

2. Make a function that will read in the data from each csv, name and organize the data correctly. 

```{r}
read_CEWL_file <- function(filename) {
  
  dat <- read.csv(file.path("data/CEWL", filename), # load file
                header = TRUE # each csv has headers
                ) %>%
    # select only the relevant values
    dplyr::select(date = Date, 
                  time = Time, 
                  status = Status,
                  ID_rep_no = Comments,
                  CEWL_g_m2h = 'TEWL..g..m2h..', 
                  msmt_temp_C = 'AmbT..C.', 
                  msmt_RH_percent = 'AmbRH....'
                  ) %>%
    # extract individual_ID and replicate number
    dplyr::mutate(ID_rep_no = as.character(ID_rep_no),
                  individual_ID = as.numeric(substr(ID_rep_no, 1, 3)),
                  replicate_no = as.numeric(substr(ID_rep_no, 5, 5))
                  )
  
  # return the dataframe for that single csv file
  dat
}
```

3. Apply the function I made to all of the filenames I compiled, then put all of those dataframes into one dataframe. This will print warnings saying that header and col.names are different lengths, because the data has extra notes cols that we read-in, but get rid of.

4. Filter out failed measurements and properly format data classes.

```{r}
# apply function to get data from all csvs
all_CEWL_data <- lapply(filenames, read_CEWL_file) %>%
  # paste all data files together into one df by row
  reduce(rbind) %>%
  # only use completed measurements
  dplyr::filter(status == "Normal") %>%
  # properly format data classes
  mutate(date_time = as.POSIXct(paste(date, time), 
                                format = "%m/%d/%y %I:%M:%S %p"),
         date = as.Date(date, 
                        format = "%m/%d/%y"),
         time = as.POSIXct(time, 
                           format = "%I:%M:%S %p"),
         status = as.factor(status),
         individual_ID = as.factor(individual_ID),
         #replicate_no = as.factor(replicate_no)
         # don't make replicate a factor
         # that way I can easily add new levels later
         )
summary(all_CEWL_data)
```

5. Load in and format the cloacal temperature measured at the time of CEWL measurement.

```{r}
cloacal_temp_C <- read.csv("./data/c_temps.csv", # filename
                             na.strings=c("","NA") # fix empty cells
                             ) %>%
  # select variables of interest
  dplyr::select(date, time_c_temp, 
                day, 
                individual_ID, 
                cloacal_temp_C) %>%
  # properly format data classes
  mutate(date_time = as.POSIXct(paste(date, time_c_temp), 
                                format = "%m/%d/%y %H:%M"),
         date = as.Date(date, format = "%m/%d/%y"),
         time_c_temp = (as.POSIXct(time_c_temp, format = "%H:%M")),
         day = as.factor(day),
         individual_ID = as.factor(individual_ID),
         cloacal_temp_C = as.numeric(cloacal_temp_C)
         ) %>%
  # get rid of rows with missing data
  dplyr::filter(complete.cases(.))
summary(cloacal_temp_C)
```

6. Load in and format the tmt assignments so we know which lizards were removed from the experiment.

```{r}
tmt <- read.csv("./data/tmt_assignments.csv") %>%
  # properly format data classes
  mutate(trial_number = as.factor(trial_number),
         temp_tmt = as.factor(temp_tmt),
         humidity_tmt = as.factor(humidity_tmt),
         individual_ID = as.factor(individual_ID),
         conclusion = as.factor(conclusion)
         )
summary(tmt)

# specifically save a df of canceled ones
canceled <- tmt %>%
  dplyr::filter(conclusion == "canceled") %>%
  dplyr::select(individual_ID)
canceled
```




# Check Data

## Dates

We should only have measurements from day 0 (beginning of date ranges below) and day 8 (end of date ranges below) for each trial.

Trail 1: June 16-24
Trail 2: June 26 - July 4
Trial 3: July 20-28
Trial 4: August 8-16
Trial 5: August 22-30

```{r}
all_CEWL_data %>%
  group_by(date) %>%
  summarise(count = n())
```

All the correct dates, and only the correct dates, are in our dataset. In every trial except trial 5, the number of observations decreases post-experiment compared to pre-experiment, either due to lost lizards or the few that died during the experiment.


## Number of Measurements

Each individual should have 10 total measurements (5 before the experiment, 5 after). 

```{r}
rep_check <- all_CEWL_data %>%
                group_by(individual_ID) %>%
                summarise(n = n()) %>% 
                arrange(n)
rep_check
```

Oof... Many individuals have more or less than 10 CEWL measurements.

too many: 206 & 215 = 11; 237 & 302 = 15
too few: 254 = 3; 213, 216, 245, 278, 289, 294, 305 = 9

There are also a handful with 5 measurements... Check whether these are the ones that had their treatment canceled (thus would only have measurements from pre experiment, not post).

```{r}
# get the individuals with only 5 measures
rep_check5_msmts <- rep_check %>% 
  dplyr::filter(n == 5)
rep_check5_msmts
# when individuals with 5 reps makes sense
rep_check5_msmts %>% 
  dplyr::filter(individual_ID %in% canceled$individual_ID)
```


Of the 7 individuals with only 5 CEWL values, 5 individual lizards (*212*, *233*, *248*, *283*, *284*) had their treatment canceled, so we have an explanation for their missing data.

```{r}
# when individuals with 5 reps DOES NOT make sense
rep_check5_msmts %>% 
  dplyr::filter(individual_ID %nin% canceled$individual_ID)
```

239 and 303 having 5 values is still unexplained and may be due to an error.

```{r}
# individuals with canceled tmt but msmt n != 5
canceled %>% dplyr::filter(individual_ID %nin% rep_check5_msmts$individual_ID)
# check their n's
rep_check %>% dplyr::filter(individual_ID %in% c(254, 304))

# check why canceled
tmt %>% dplyr::filter(individual_ID %in% c(254, 304))
```


Individuals 254 and 304 had their treatments canceled, but their n!=5. 254 only had 3 measurements taken because they were lost during CEWL measurement pre-treatment. Individual 304 has the correct number of observations (10), but it was canceled because we realized after the experiment that his toe was already clipped, thus was a recapture from a previous trial and we did not want to include his data. There were no measurement errors for these individuals. Whereas 254's capture measurements can be used for the capture analysis, 304's measurements should be removed from the dataset completely.


Save the individuals with measurement n's that I need to investigate further.

```{r}
indiv_too_few <- rep_check %>% dplyr::filter(n == 9)
indiv_too_many <- rep_check %>% dplyr::filter(n > 10)
other_weird <- rep_check %>% dplyr::filter(individual_ID %in% 
                                             c(239, 303)) # only 5 msmts

# save together to investigate further
weird_n <- indiv_too_few %>%
  rbind(indiv_too_many, other_weird) %>%
  arrange(n)
weird_n
```


Next, check how many measurements each individual has for each date.

```{r}
rep_check_1a <- all_CEWL_data %>%
  dplyr::filter(individual_ID %nin% weird_n$individual_ID) %>%
                group_by(individual_ID, date) %>%
                summarise(n = n()) %>% 
                arrange(n)
rep_check_1a
unique(rep_check_1a$n)
```

It seems I have extracted all of the weird measurements. Every n on a given date ==5 for the individuals not included in my dataframe "weird_n", with the exception of individual 254, which I've already accounted for.

Now I can focus on the observations for the individuals in weird_n.

```{r}
# save ones with one day of 5 msmts so I can filter out others' complete days
two_5s <- all_CEWL_data %>%
  dplyr::filter(individual_ID %in% c(239, 303)) %>%
  group_by(individual_ID, date) %>%
  summarise(n = n())
# get the weird msmt days for others
rep_check_1b <- all_CEWL_data %>%
  dplyr::filter(individual_ID %in% weird_n$individual_ID) %>%
  group_by(individual_ID, date) %>%
  summarise(n = n()) %>% 
  dplyr::filter(n!=5) %>%
  rbind(two_5s) %>%
  arrange(n)
rep_check_1b
```

I have yet to figure out why individuals 213 and 216 (June 24), 245 (July 4), 278 and 289 (July 28), 294 and 305 (August 16) only have 4 observations on that date. The most likely explanation is that we miscounted replicates and only did 4, rather than 5. They have the correct number of measurements on their other measurement days.

Individuals 206 and 215 both have one extra replicate on June 24. Individuals 237 and 302 both have **10** replicates! On July 4 and August 8, respectively. They have the correct number of measurements on their other measurement days.

239 and 303 only have one day of measurements.

I will need to do more digging to figure out why these individuals have the wrong number of measurements on these dates.



## Extra/Missing Measurements

Get all the data for the ones that aren't right:

```{r}
rep_check_2 <- all_CEWL_data %>%
  left_join(rep_check_1b, by = c("individual_ID", "date")) %>%
  dplyr::filter(complete.cases(n))
```

Look at the weird data one at a time, starting with sets with too many replicates.

```{r}
rep_check_2 %>%
  dplyr::filter(individual_ID == 302)
tmt %>%
  dplyr::filter(individual_ID == 302)
```

Individual 302 has two sets of replicates from his capture day. One set is probably from him and the other set belongs to the lizard measured before or after him. Thankfully, on capture day, lizards are measured in number order, so I know it's probably either Individual 301 or 303. Since 303 is missing measurements, we'll check that.

```{r}
all_CEWL_data %>%
  dplyr::filter(individual_ID == 303)
tmt %>%
  dplyr::filter(individual_ID == 303)
```

As suspected, Individual 303 only has pre-experiment measurements. We can check the time cloacal temperature was measured for these lizards on capture day to see which set of CEWL measurements belongs to who.

```{r}
cloacal_temp_C %>% 
  dplyr::filter(individual_ID %in% c(302,303) & 
                  date == as.Date("2021-08-08"))
```

302's temperature was taken at 13:06 and 303's temperature was taken at 13:13, so **the 13:01-13:05 CEWL measurements are for 302 and the 13:09-13:12 CEWL measurements are for 303**.


Discrepancies in number of measurements for individuals 302 and 303 solved!

```{r}
rep_check_3 <- rep_check_2 %>%
  dplyr::filter(individual_ID %nin% c(302, 303)) %>%
  arrange(individual_ID)
# remaining individuals with replicate n's to investigate
unique(rep_check_3$individual_ID)
```


Next:

```{r}
rep_check_2 %>%
  dplyr::filter(individual_ID == 237)
tmt %>%
  dplyr::filter(individual_ID == 237)
```

Individual 237 also has an extra set of replicate measurements on the post-experiment day. The two sets of measurements are taken at two very different time blocks: 10:26-10:32 vs 12:21-12:24.

Interestingly, a closeby number is missing some measurements:

```{r}
rep_check_2 %>%
  dplyr::filter(individual_ID == 239)
tmt %>%
  dplyr::filter(individual_ID == 239)
```

Individual 239 is missing his post-experiment measurements on July 4. So, see if I can use cloacal temperature measurement times again to fix:

```{r}
cloacal_temp_C %>% 
  dplyr::filter(individual_ID %in% c(237,239) & 
                  date == as.Date("2021-07-04"))
```

237's temperature was taken at 12:24 and 239's temperature was taken at 10:33, so **the 12:21-12:24 CEWL measurements are for 237 and the 10:26-10:32 CEWL measurements are for 239**.


Discrepancies in number of measurements for individuals 237 and 239 solved!

Update list of individuals to investigate: 

```{r}
rep_check_4 <- rep_check_3 %>%
  dplyr::filter(individual_ID %nin% c(237, 239)) %>%
  arrange(individual_ID)
# remaining individuals with replicate n's to investigate
unique(rep_check_4$individual_ID)
```

Next:

```{r}
rep_check_2 %>%
  dplyr::filter(individual_ID == 215)
```

The measurement from June 24 at 11:53:32 has a completely different time and CEWL value than the other measurements for Individual 215 on that day. I can check cloacal temperature times from that day to make sure it's not a measurement for 215 and check whether it might belong to someone else.

```{r}
cloacal_temp_C %>% 
  dplyr::filter(date == as.Date("2021-06-24")) %>%
  arrange(time_c_temp)
```

215 had his cloacal temperature taken at 11:16, confirming that only the CEWL values from between 11:12-11:16 are his. Individual 213 had his cloacal temp taken at 11:53, and 226 had his taken at 11:58. Now I can check whether either of them are missing CEWL values and what time their CEWL measurements were taken.

```{r}
rep_check_2 %>%
  dplyr::filter(individual_ID == 213)
all_CEWL_data %>%
  dplyr::filter(individual_ID == 226)
```

Individual 226 isn't missing anything. BUT, individual 213 is missing his fifth replicate of CEWL measurements taken post-experiment. The 4 measurements currently attributed to him were taken between 11:49-11:52, so the extra value attributed to 215 at 11:53 fits perfectly into that sequence of replicates.


Discrepancies in number of measurements for individuals 215 and 213 solved!

Update list of individuals to investigate: 

```{r}
rep_check_5 <- rep_check_4 %>%
  dplyr::filter(individual_ID %nin% c(215, 213)) %>%
  arrange(individual_ID)
# remaining individuals with replicate n's to investigate
unique(rep_check_5$individual_ID)
```

Next:

```{r}
rep_check_2 %>%
  dplyr::filter(individual_ID == 206)
```

Individual 206 has two #2 replicates taken at 11:37, just 40 seconds apart, which is the normal time in-between back-to-back measurements when there are no distractions. So, the extra measurement can be considered a sixth replicate and should be relabeled as such. 

Mystery for Individual 206's weird number of replicates is solved.


Update list of individuals to investigate: 

```{r}
rep_check_6 <- rep_check_5 %>%
  dplyr::filter(individual_ID != 206) %>%
  arrange(individual_ID)
# remaining individuals with replicate n's to investigate
unique(rep_check_6$individual_ID)
```

Next:

```{r}
rep_check_2 %>%
  dplyr::filter(individual_ID == 216)
```

Individual 216 is missing his 4th replicate. There is only one minute between replicates 3 and 5, so I believe the 4th replicate got accidentally skipped/forgotten.

216's mystery solved!

Update list of individuals to investigate: 

```{r}
rep_check_7 <- rep_check_6 %>%
  dplyr::filter(individual_ID != 216) %>%
  arrange(individual_ID) %>%
  group_by(individual_ID, date) %>%
  summarise(n = n())
# remaining individuals with replicate n's to investigate
rep_check_7
```

The remaining individuals had only 4 replicates on one day, which is probably for the same reason as 216- one replicate was forgotten/we miscounted replicate numbers. No adjustment possible/necessary.

All unexpected n's are explained.

Make note of which individuals still won't have n = 5/10:

```{r}
unconforming_but_fine <- data.frame(IDs = c(216, 245, 278, 289, 294, 305,
                                            206, 254),
                                    total_n = c(9, 9, 9, 9, 9, 9,
                                                11, 3),
                                    single_date_n = c(4, 4, 4, 4, 4, 4,
                                                      6, 3)
                                    )
```



## Properly Re-Assign Measurements

1. 304's measurements should be removed from the dataset completely. This should remove 10 rows of data. Also give the dataset a specific order to follow to make indexing correct.

```{r}
nrow(all_CEWL_data)
all_CEWL_data %>%
  dplyr::filter(individual_ID == 304)
all_CEWL_data_edited <- all_CEWL_data %>%
  dplyr::filter(individual_ID != 304) %>%
  arrange(date, individual_ID, time, replicate_no)
nrow(all_CEWL_data_edited)
all_CEWL_data_edited %>%
  dplyr::filter(individual_ID == 304)
```

2. Reassign the measurements attributed to individual 302 taken between 13:09-13:12 on August 8 as pre-experiment measurements for individual 303. 

```{r}
all_CEWL_data_edited[936:945, ]
all_CEWL_data_edited[941:945, "individual_ID"] <- 303
all_CEWL_data_edited[936:945, ]
```


3. Reassign the measurements attributed to individual 237 taken between 10:26-10:32 on July 4 as post-experiment measurements for individual 239. 

```{r}
all_CEWL_data_edited[459:468, ]
all_CEWL_data_edited[459:463, "individual_ID"] <- 239
all_CEWL_data_edited[459:468, ]
```


4. Reassign the measurement attributed to individual 215 at 11:53 on June 24 as the fifth replicate for individual 213 on that date.

```{r}
all_CEWL_data_edited[187:201, ]
all_CEWL_data_edited[201, "replicate_no"] <- 5
all_CEWL_data_edited[201, "individual_ID"] <- 213
all_CEWL_data_edited[187:201, ]
```


5. Relabel one of 206's June 24 #2 replicates as 206's sixth replicate.

```{r}
all_CEWL_data_edited[156:161, ]
all_CEWL_data_edited[158, "replicate_no"] <- 6
all_CEWL_data_edited[156:161, ]
```



# Re-Check Data

## Dates

```{r}
all_CEWL_data_edited %>%
  group_by(date) %>%
  summarise(count = n())
```

Still correct.


## Number of Measurements

Each individual should have 10 total measurements (5 before the experiment, 5 after). 

```{r}
unconforming_but_fine
canceled
all_CEWL_data_edited %>%
  group_by(individual_ID) %>%
  summarise(n = n()) %>% 
  arrange(n)
all_CEWL_data_edited %>%
  group_by(individual_ID, date) %>%
  summarise(n = n()) %>% 
  arrange(n)
```

Every number of replicates is explained, whether it was the expected n (5/10) or not.


## Measurement Times

Also check that all the measurement times for a given individual on a certain date are within ~10 minutes:

```{r}
all_CEWL_data_edited %>%
  group_by(individual_ID, date) %>%
  summarise(min_time = min(date_time),
            max_time = max(date_time),
            msmt_time_range_minutes = ((max_time-min_time)/60)) %>%
  dplyr::select(individual_ID, date, msmt_time_range_minutes) %>%
  arrange(msmt_time_range_minutes)
```


I want to double check on individuals 305 on August 16 and 233 on June 26 because they have measurement time ranges of ~10.5 and ~91 minutes, respectively, which is much greater than the typical 1.7-7.8 minute range for all the other individuals.

```{r}
# CEWL
all_CEWL_data_edited %>%
  dplyr::filter(individual_ID %in% c(305, 233))
# cloacal temps
cloacal_temp_C %>%
  dplyr::filter(individual_ID %in% c(305, 233))
```

The cloacal temperature for individual 305 was taken at 12:15 on August 16, which is right after the fifth replicate was recorded. Either the fourth replicate did not have a "Normal" (successful) measurement, or we got distracted and miscounted. The time range for 305 is fine.

The measurement for individual 233 at 14:13 must have been an incorrectly labeled measurement for another individual, since his cloacal temperature was taken at 12:45. 

I can check whether any of the individuals with 4 replicates are missing one on that day:

```{r}
rep_check_6 %>%
  group_by(individual_ID, date) %>%
  summarise(n = n()) #%>%
  #dplyr::filter(date == as.Date("2021-06-26"))
```

Nothing matches. I think the measurement taken for individual 233 1.5 hours later than his other replicates should still be omitted since we cannot be confident that measurement was on him, and his cloacal temperature was taken prior to that CEWL measurement, which is contrary to our protocol of taking all CEWL measurements then .

## Omit Temporal Outlier

This should remove one row of data.

```{r}
nrow(all_CEWL_data_edited)
all_CEWL_data_edited2 <- all_CEWL_data_edited %>%
  dplyr::filter(individual_ID != 233 | # or 
                  date_time != as.POSIXct("2021-06-26 14:13:10")) %>%
  arrange(date, individual_ID, time, replicate_no)
nrow(all_CEWL_data_edited2)
```

Check the values again:

```{r}
all_CEWL_data_edited2 %>%
  dplyr::filter(individual_ID %in% c(233))
```

## Re-Check Measurement Times

```{r}
all_CEWL_data_edited2 %>%
  group_by(individual_ID, date) %>%
  summarise(min_time = min(date_time),
            max_time = max(date_time),
            msmt_time_range_minutes = (max_time-min_time)) %>%
  dplyr::select(individual_ID, date, msmt_time_range_minutes) %>%
  arrange(msmt_time_range_minutes)
```


## Replicate Numbers

Replicates are numbered 1-5, so I can check whether the replicate numbers listed for each individual sum to the correct amount, with the exception of the individuals I know do not have 5 replicates on a given day.

```{r}
# proper sum
rep_sum <- sum(1, 2, 3, 4, 5)
rep_sum # 15
# calculate for each individual
all_CEWL_data_edited2 %>%
  group_by(individual_ID, date) %>%
  summarise(rep_sum = sum(as.numeric(replicate_no))) %>%
  dplyr::filter(rep_sum != 15) -> test_rep_nos
test_rep_nos
# compare to my list of known incorrect values
test_rep_nos$individual_ID %in% weird_n$individual_ID
```

Individuals 233 (sum 11) and 254 (sum 6) are missing from the weird_n list, but still have an incorrect replicate sum. I just previously discovered that 233 is missing his fourth replicate, and 254 only had three replicates measured before he escaped. 

So, every individual on every date has the correct number of and properly labeled replicates. Now the replicates can be interrogated for outliers, then averaged into one observation for each individual on each date.


# Replicates

## Assess Variation

We want the Coefficient of Variation (CV) among our technical replicates to be small. We need to calculate it to identify whether there may be outliers.

```{r}
CVs <- all_CEWL_data_edited2 %>%
  group_by(individual_ID, date) %>%
  summarise(mean = mean(CEWL_g_m2h),
            SD = sd(CEWL_g_m2h),
            CV = (SD/mean) *100,
            min = min(CEWL_g_m2h),
            max = max(CEWL_g_m2h),
            range = max - min
            )
summary(CVs)
hist(CVs$CV)
hist(CVs$range) 
```

We expect CV for technical replicates to be < 10-15%, so we must determine whether the CVs > 15% are due to outlier replicates.


## Find Outliers

First, create a function to look at the replicates for each individual on each day. This will be almost 300 iterations of the function. For each iteration, I will make a boxplot and extract any outliers, compiling a dataframe of outliers that I want to exclude from the final dataset. By printing the boxplots and compiling a dataframe of outliers, I can check the data against the plots to ensure confidence in the outliers quantified.

```{r}
# write function to find outliers for each individual on each date
find_outliers <- function(df) {
  
  # initiate dataframe to compile info and list to compile plots
  outliers <- data.frame()
  #boxplots <- list()

  # initiate a for loop to go through every who in df
  for(indiv_ch in unique(df$individual_ID)) {
    
    # select data for only the individual of interest
    df_sub <- df %>%
      dplyr::filter(individual_ID == as.numeric(indiv_ch))
    
    # make a boxplot
    df_sub %>%
      ggplot(.) +
      geom_boxplot(aes(x = as.factor(date),
                       y = CEWL_g_m2h,
                       fill = as.factor(date))) +
      ggtitle(paste("Individual", indiv_ch)) +
      theme_classic() -> plot
    
    # print/save
    print(plot)
    #boxplots[[indiv_ch]] <- plot
    
    # extract outliers
    outs <- df_sub %>%
      group_by(individual_ID, date) %>%
      summarise(outs = boxplot.stats(CEWL_g_m2h)$out)
    
    # add to running dataframe of outliers
    outliers <- outliers %>%
      rbind(outs)
  }
  #return(boxplots)
  return(outliers)
}
```


Now apply the function to the data:

```{r, fig.show="hold", out.width="50%"}
par(mfrow = c(71, 2))
outliers_found <- find_outliers(all_CEWL_data_edited2)
outliers_found
par(mfrow = c(1, 1))
```

Based on the plots, the dataframe of outliers I compiled is correct.


## Remove Outliers

Now I will create a secondary version of the same function, but instead of compiling outliers, I will omit them from the dataset.

```{r}
# write function to find and exclude outliers
omit_outliers <- function(df) {
  
  # initiate dataframe to compile info and list to compile plots
  cleaned <- data.frame()

  # initiate a for loop to go through every who in df
  for(indiv_ch in unique(df$individual_ID)) {
    
    # select data for only the individual of interest
    df_sub <- df %>%
      dplyr::filter(individual_ID == as.numeric(indiv_ch))
    
    # extract outliers
    outs <- df_sub %>%
      group_by(individual_ID, date) %>%
      summarise(outs = boxplot.stats(CEWL_g_m2h)$out)
    
    # filter outliers from data subset for this individual
    filtered <- df_sub %>%
      dplyr::filter(CEWL_g_m2h %nin% outs$outs)
    
    # add to running dataframe of cleaned data
    cleaned <- cleaned %>%
      rbind(filtered)
  }
  return(cleaned)
}
```


Apply function to data and check that the new data subsets still contain the right amount of data:

```{r}
outliers_omitted <- omit_outliers(all_CEWL_data_edited2)
nrow(all_CEWL_data_edited2) == nrow(outliers_omitted) + nrow(outliers_found)
```




## Re-Assess Variation

```{r}
new_CVs <- outliers_omitted %>%
  group_by(individual_ID, date) %>%
  summarise(mean = mean(CEWL_g_m2h),
            SD = sd(CEWL_g_m2h),
            CV = (SD/mean) *100,
            min = min(CEWL_g_m2h),
            max = max(CEWL_g_m2h),
            range = max - min)
summary(new_CVs)
hist(new_CVs$CV)
hist(CVs$CV)
hist(new_CVs$range) 
hist(CVs$range) 
```


Unfortunately, CVs are still skewed to the right, but overall, CVs are much lower and are mostly < 5-10%. We will continue with this dataset.


## Average Replicates (outliers removed) & Join Cloacal Temp Data

```{r}
CEWL_final <- outliers_omitted %>%
  group_by(date, individual_ID) %>%
  summarise(CEWL_g_m2h = mean(CEWL_g_m2h)) %>%
  left_join(cloacal_temp_C, by = c('date', 'individual_ID')) %>%
  dplyr::filter(complete.cases(CEWL_g_m2h, cloacal_temp_C))
head(CEWL_final)
```


# Final Synthesis

## Re-Check Data

Check that we still have data for every individual, except for 254 and 304. 254 did not have his cloacal temperature taken before escaping, thus could not be included in any capture day models. 304 was omitted completely because he was accidentally recaptured and we only want his data from the first time he was included in the experiment.

I can check this by comparing a list of the individual IDs used (201-341) to the individual IDs in our final dataset, then selecting/printing the IDs used that are not in the final dataset.

```{r}
c(seq(201, 341, 1))[c(seq(201, 341, 1)) %nin% unique(CEWL_final$individual_ID)]
```

We expected individuals 254 and 304 not to be in the final dataset, so all is as expected.

Check how many observations were used to calculate mean CEWL for each individual on each date:

```{r}
outliers_omitted %>%
  group_by(individual_ID, date) %>%
  summarise(n = n()) %>% 
  arrange(n)
```


Between 3-6, awesome! That means we omitted 2 or less replicates for each individual on each measurement date.


## Export

Save the cleaned data for models and figures.

```{r}
write.csv(CEWL_final, "./data/CEWL_dat_all_clean.csv")
```





## Reporting

We omitted a total of 136 measurements from our CEWL dataset. We realized post-experiment that individual 304 was a recapture, and had already undergone experimental conditions once before, so his data was completely excluded. One measurement attributed to individual 233 on June 26 was made 1.5 hours later than his other CEWL measurements and cloacal temperature on that day, which would represent a major deviation from our protocol. This measurement could not be confidently, truly attributed to individual 233, thus was omitted. We used the boxplot.stats function in R to extract outliers from each set of technical replicates, totaling 134 points qualifying as outliers which were thus removed.

After data cleaning, every individual still had at least 3 technical replicates for each of their measurement dates, with most individuals retaining all 5 original replicates. The distribution of coefficient of variation values was more-heavily distributed between 0-10% after data cleaning than before.



