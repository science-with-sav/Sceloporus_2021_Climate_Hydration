---
title: "Climate Water Loss Experiment - Capture Hydration Analysis"
author: "Savannah Weaver"
date: "2021"
output: pdf_document
toc: TRUE
---


# Packages

```{r setup, include = TRUE, message = FALSE}
if (!require("tidyverse")) install.packages("tidyverse")
library("tidyverse") # workflow and plots
if (!require("zoo")) install.packages("zoo")
library("zoo") # interpolation using na.approx
if (!require("weathermetrics")) install.packages("weathermetrics")
library("weathermetrics") # F to C conversion
if (!require("PerformanceAnalytics")) install.packages("PerformanceAnalytics") 
library("PerformanceAnalytics") # pretty multicollinearity plots
if (!require("UsingR")) install.packages("UsingR")
library("UsingR")
if (!require("lme4")) install.packages("lme4")
library("lme4") # for LMMs
if (!require("lmerTest")) install.packages("lmerTest")
library("lmerTest") # for p-values
if (!require("onewaytests")) install.packages("onewaytests")
library("onewaytests") # for Brown-Forsythe test
if (!require("ggpubr")) install.packages("ggpubr")
library("ggpubr") # for multi-ggplot figs
if (!require("broom")) install.packages("broom")
library("broom") # lmer model export
if (!require("broom.mixed")) install.packages("broom.mixed")
library("broom.mixed") # lmer model export
```


# Background and Goals

This data was collected June - August by Master's student Savannah Weaver, advisor Dr. Emily Taylor, and research assistants Tess McIntyre and Taylor Van Rossum. Adult male *Sceloporus occidentalis* were caught across the Cal Poly campus and in Poly Canyon. This R file analyzes the state and variation of osmotic balance and regulation at the time of capture. Please refer to **doi:** for the published scientific journal article and full details.


# Data

## Load

Read-in and attach all data. Details described later.

```{r}
        # mass and hematocrit data
full_dat <- read.csv("./data/mass_hct_notes.csv", # filename
                             na.strings=c("","NA") # fix empty cells
                             ) %>%
        # format date to enable joining by date
  mutate(measurement_date = as.character(as.Date(measurement_date, 
                                          format = "%m/%d/%y"))
         ) %>%
        # join plasma osmolality data
  left_join(read.csv("./data/osml_means_clean.csv", # filename
                             na.strings=c("","NA") # fix empty cells
            ), by = c("individual_ID", 
                      "measurement_date" = "date_blood_drawn")
            ) %>%
        # join CEWL data
  left_join(read.csv("./data/CEWL_dat_all_clean.csv", # filename
                             na.strings=c("","NA") # fix empty cells
            ), by = c("individual_ID", 
                      "measurement_date" = "date")
            ) %>%
        # select variables of interest only
  dplyr::select(measurement_date,
                time_captured,
                time_processed,
                time_c_temp,
                type, day, 
                individual_ID,
                mass_g, 
                hemolyzed,
                hematocrit_percent, 
                osmolality_mmol_kg_mean,
                CEWL_g_m2h_mean = CEWL_g_m2h,
                cloacal_temp_C
                ) %>%
          # format date-time-related variables
  mutate(measurement_date = as.Date(measurement_date, 
                                    format = "%Y-%m-%d")) %>%
  group_by(individual_ID) %>%
          # for each individual, extract capture date
  mutate(capture_date = min(measurement_date),
         day_n = as.numeric(measurement_date - capture_date))

summary(full_dat)
# check
unique(full_dat$capture_date)
```


## Export

Export full_dat to be used in 'experiment_analysis'.

```{r}
write.csv(full_dat, "./data/full_exp_data.csv")
```


## Format

Extract only the data from capture day (1 row of observations for each individual) and format the data classes properly for analysis.

```{r}
capture_dat <- full_dat %>%
          # select only data from capture days
  dplyr::filter(day_n == 0) %>%
  left_join(read.csv("./data/tmt_assignments.csv"),
            by = "individual_ID") %>%
          # put date and time together
  mutate(capture_date_time = (paste(capture_date, time_captured)),
         capture_date_time = as.POSIXct(capture_date_time, 
                                        format = "%Y-%m-%d %H:%M"),
          # correctly format time-only variables
         time_captured = as.POSIXct(time_captured, 
                                     format = "%H:%M"),
         time_processed = as.POSIXct(time_processed, 
                                      format = "%H:%M"),
         time_c_temp = as.POSIXct(substr(time_c_temp, 12, 16), 
                                  format = "%H:%M"),
          # set categorical variables as factors
         type = as.factor(type),
         day = as.factor(day),
         individual_ID = as.factor(individual_ID),
         hemolyzed = as.factor(hemolyzed),
          # set numeric measurements as numeric
         mass_g = as.numeric(mass_g),
         hematocrit_percent = as.numeric(hematocrit_percent),
         osmolality_mmol_kg_mean = as.numeric(osmolality_mmol_kg_mean),
         CEWL_g_m2h_mean = as.numeric(CEWL_g_m2h_mean),
         cloacal_temp_C = as.numeric(cloacal_temp_C)
                ) %>%
  # make sure only complete data included
  # this removes the data for individuals 304 (recapture) & 254 (escapee)
  dplyr::filter(complete.cases(osmolality_mmol_kg_mean,
                               CEWL_g_m2h_mean, cloacal_temp_C)) %>%
  # remove experiment variables not relevant to capture analysis
  dplyr::select(-trial_number, -temp_tmt, -humidity_tmt, 
                -conclusion, -notes, 
                -shed, -tail_broken, -died)
summary(capture_dat)
```




## Variable Summary

- measurement_date = date measurements were taken, including capture day
- collection/capture time for each lizard
- time_processed = when mass and blood draw were recorded
- time_c_temp = the time when cloacal temperature was recorded, immediately after CEWL measurements
- type = whether measurements were during experiment (exp) or after rehydration (post-rehab). For this R script/analysis, I'm only going to use capture day data, which is listed as "exp"
- day = whether measurements are from capture day or post-experiment, which was recorded in relation to CEWL & cloacal temp data. All observations used for this analysis will be from capture day
- individual ID for each lizard
- mass in grams
- hemolyzed = whether or not red blood cells burst and contaminated plasma
- hematocrit_percent = percent of blood that's red blood cells (measured in CRITOCAP microhematocrit capillary tubes)
- osmolality_mmol_kg_mean = the mean of 1-3 technical replicates of plasma osmolality measurements taken from plasma extracted from our blood samples and run on a VAPRO vapor pressure osmometer
- CEWL_g_m2h_mean = the mean of 3-5 technical replicates, after outliers were omitted, of CEWL measurements taken in the same area of the dorsum
- cloacal_temp_C = cloacal temperature recorded immediately after CEWL measurements
- capture_date = date of capture. For this dataset, it should be the same as measurement date
- day_n = numeric day of measurement. In this dataset, it should always be zero
- capture_date_time = combination of capture date and time
- SVL_mm = snout-to-vent length in mm



## Weather Data

This data was obtained from http://www.itrc.org/databases/precip/ (Adcon Server Data) to test the effect of ambient conditions on CEWL.

Load and format: 

```{r}
weather <- read.csv("./data/weather.csv", sep = ';') %>%
         # add a variable for combined date-time
  mutate(capture_date_time = as.POSIXct(paste(date, time),
                                format = "%m/%d/%y %I:%M %p"))
```

The weather data is only every 15 minutes, but I want to match it to any minute measurement, so I need to interpolate the values for each minute.

First, make a separate dataframe with every minute on each capture day.

```{r}
all_times <- data.frame(capture_date_time = c(
                           # June 16
                           seq(from = as.POSIXct("2021-06-16 07:00"),
                               to = as.POSIXct("2021-06-16 19:00"),
                               by="min"),
                           # June 26
                           seq(from = as.POSIXct("2021-06-26 07:00"),
                               to = as.POSIXct("2021-06-26 19:00"),
                               by="min"),
                           # July 20
                           seq(from = as.POSIXct("2021-07-20 07:00"),
                               to = as.POSIXct("2021-07-20 19:00"),
                               by="min"),
                           # August 8
                           seq(from = as.POSIXct("2021-08-08 07:00"),
                               to = as.POSIXct("2021-08-08 19:00"),
                               by="min"),
                           # August 22
                           seq(from = as.POSIXct("2021-08-22 07:00"),
                               to = as.POSIXct("2021-08-22 19:00"),
                               by="min")
                           ))

```

Next, merge the weather data into the times dataframe and interpolate the temperature and humidity between measurements.

```{r}
weather_every_minute <- all_times %>% # time only dataframe
  # add weather measurements based on matching date-time
  left_join(weather, by = 'capture_date_time') %>%
         # convert temperature units F->C
  mutate(temp_C = fahrenheit.to.celsius(temperature_F, round = 2),
         # interpolate temperatures
         temp_C_interpol = na.approx(temp_C),
         # also get temperature C-> K
         temp_K_interpol = temp_C_interpol + 273.15,
         # interpolate humidities
         RH_percent_interpol = na.approx(relative_humidity_percent),
         # interpolate Wind Speeds
         wind_mph_interpol = na.approx(wind_speed_mph),
         # interpolate solar radiation
         solar_rad_W_sqm_interpol = na.approx(solar_radiation_W_sqm),
         # compute vapor pressure deficit
         # find saturation level first
         e_s_kPa_int = 0.611*exp((2500000/461.5)*
                                  ((1/273)-(1/temp_K_interpol))),
         # actual vapor pressure
         e_a_kPa_int = e_s_kPa_int * (RH_percent_interpol/100),
         # VPD
         VPD_kPa_int = e_s_kPa_int - e_a_kPa_int
         ) %>%
  # keep only the relevant variables
  dplyr::select(capture_date_time, 
                temp_C_interpol, 
                RH_percent_interpol, 
                VPD_kPa_int,
                wind_mph_interpol, 
                solar_rad_W_sqm_interpol)
summary(weather_every_minute)
```

I will add the weather data in when I add the scaled mass index (computed next) to the dataframe.



## Compute Scaled Mass Index

This is also known as the body condition index, or log-log residuals.

I calculate as described by: Peig, J., & Green, A. J. (2009). New perspectives for estimating body condition from mass/length data: The scaled mass index as an alternative method. Oikos, 118(12), 1883–1891. https://doi.org/10.1111/j.1600-0706.2009.17643.x

### Step 1: Simple Linear Regression

```{r}
mass_SVL_SLR <- lm(data = capture_dat, mass_g ~ SVL_mm)
summary(mass_SVL_SLR)
```


### Step 2: Identify Outliers

```{r}
plot(mass_SVL_SLR)
```

The conditions of linearity, equal error variance, and normality are all satisfied. It doesn't look like any residuals are >3 or <-3.

```{r}
boxplot(residuals(mass_SVL_SLR))
hist(residuals(mass_SVL_SLR))
```

From the boxplot, there is one individual with a much higher residual than the rest of the distribution. The histogram looks fine, and incredibly normally distributed.

Check average residual value:

```{r}
mean(residuals(mass_SVL_SLR))
median(residuals(mass_SVL_SLR))
```

The mean is basically zero and the median is pretty close to zero, which is very good.

Check for high leverage points:

```{r}
# compute values for observations 
high_leverage <- data.frame(H = hatvalues(mass_SVL_SLR)) %>% 
  mutate(row = row_number())

# compute cutoff value 
h_bar <- (3*sum(high_leverage$H))/nrow(high_leverage)

# add to original dataframe 
# see which observations have extremely high leverage (if any)
high_leverage_dat <- capture_dat %>%
  mutate(row = row_number()) %>%
  left_join(., high_leverage, by = "row") %>%
  dplyr::filter(H > h_bar) 
high_leverage_dat
```

No points are considered high leverage, which is fantastic.

Check for influential points based on Cook's distance:

```{r}
# get Cook's distance 
cooks <- data.frame(c = cooks.distance(mass_SVL_SLR)) %>% 
  mutate(row = row_number())

# add to original dataframe 
influential <- capture_dat %>%
  mutate(row = row_number()) %>% 
  left_join(., cooks, by = "row")

# see moderately influential points 
cook_mod_inf <- influential %>% 
  dplyr::filter(c>0.5) 
cook_mod_inf
```

There are no infuential points based on Cook's distance, so there's nothing to potentially remove.

We could remove the one outlier found using the boxplot, but it's the only one, so we will leave it in the dataset. No points were indicated to be outliers based on residuals or a histogram, and there were no high leverage or influential points. Thus I can create a log-log model using the data as-is. Observation omissions are unlikely to increase generalizability.


 
### Step 3: log-log Regression

```{r}
log_mass_SVL_SLR <- lm(data = capture_dat, 
                       log(mass_g) ~ log(SVL_mm))
summary(log_mass_SVL_SLR)
```


### Step 4: Extract Values

compute standardized major axis using the log-log regression equation:

```{r}
r <- sqrt(0.5699) # Pearson's correlection coefficient (sqrt of R-squared)
b_OLS <- 2.0013 # regression slope
b_SMA <- b_OLS/r
```

mean length in capture data:

```{r}
L0 <- mean(capture_dat$SVL_mm)
```


### Step 5: Calculate Scaled Mass Index

(And join weather data.)

```{r}
capture_dat_plus <- capture_dat %>%
  # compute SMI
  mutate(SMI = mass_g * ((L0/SVL_mm) ^ b_SMA)) %>%
  # join weather data
  left_join(weather_every_minute, by = c("capture_date_time")) %>%
  # clean up the dataframe
  dplyr::select(capture_date, capture_date_time, individual_ID, # basics
                mass_g, SVL_mm, SMI, # lizard size
                hemolyzed, hematocrit_percent, osmolality_mmol_kg_mean, # blood
                CEWL_g_m2h_mean, cloacal_temp_C, # CEWL
                temp_C_interpol, VPD_kPa_int, wind_mph_interpol, solar_rad_W_sqm_interpol # weather
                )
summary(capture_dat_plus)
```


### Check

Look at the difference between regular mass and SMI:

```{r}
capture_dat_SMI %>% 
  ggplot(data = .) + 
  geom_point(aes(x = mass_g,
                 y = SMI, 
                 ), 
             size = 1, 
             alpha = 0.6) + 
  stat_smooth(aes(x = mass_g, 
                  y = SMI, 
                  ), 
              formula = y ~ x, 
              method = "lm", 
              color = "gray",
              se = F, 
              size = 1.6, 
              alpha = 1 ) + 
  theme_classic() + 
  xlab("Mass") + 
  ylab("SMI")
```






# Quick Plots

Plot very basic graphs to get an idea of what variables to incorporate into models and how.

## Osmolality

```{r}
plot(capture_dat_plus$individual_ID,
     capture_dat_plus$osmolality_mmol_kg_mean)
plot(capture_dat_plus$capture_date,
     capture_dat_plus$osmolality_mmol_kg_mean)
plot(capture_dat_plus$mass_g,
     capture_dat_plus$osmolality_mmol_kg_mean)
plot(capture_dat_plus$SVL_mm,
     capture_dat_plus$osmolality_mmol_kg_mean)
plot(capture_dat_plus$SMI,
     capture_dat_plus$osmolality_mmol_kg_mean)
plot(capture_dat_plus$hemolyzed,
     capture_dat_plus$osmolality_mmol_kg_mean)
plot(capture_dat_plus$hematocrit_percent,
     capture_dat_plus$osmolality_mmol_kg_mean)
plot(capture_dat_plus$CEWL_g_m2h_mean,
     capture_dat_plus$osmolality_mmol_kg_mean)
plot(capture_dat_plus$temp_C_interpol,
     capture_dat_plus$osmolality_mmol_kg_mean)
plot(capture_dat_plus$VPD_kPa_int,
     capture_dat_plus$osmolality_mmol_kg_mean)
plot(capture_dat_plus$wind_mph_interpol,
     capture_dat_plus$osmolality_mmol_kg_mean)
plot(capture_dat_plus$solar_rad_W_sqm_interpol,
     capture_dat_plus$osmolality_mmol_kg_mean)
```

There does not appear to be a meaningful visual trend for plasma osmolality, so it will be interesting to see how the model selection process goes... There is definitely an increase in osmolality over the course of the season, though.


## CEWL

```{r}
plot(capture_dat_plus$individual_ID,
     capture_dat_plus$CEWL_g_m2h_mean)
plot(capture_dat_plus$capture_date,
     capture_dat_plus$CEWL_g_m2h_mean)
plot(capture_dat_plus$mass_g,
     capture_dat_plus$CEWL_g_m2h_mean)
plot(capture_dat_plus$SVL_mm,
     capture_dat_plus$CEWL_g_m2h_mean)
plot(capture_dat_plus$SMI,
     capture_dat_plus$CEWL_g_m2h_mean)
plot(capture_dat_plus$hematocrit_percent,
     capture_dat_plus$CEWL_g_m2h_mean)
plot(capture_dat_plus$osmolality_mmol_kg_mean,
     capture_dat_plus$CEWL_g_m2h_mean)
plot(capture_dat_plus$cloacal_temp_C,
     capture_dat_plus$CEWL_g_m2h_mean)
plot(capture_dat_plus$temp_C_interpol,
     capture_dat_plus$CEWL_g_m2h_mean)
plot(capture_dat_plus$VPD_kPa_int,
     capture_dat_plus$CEWL_g_m2h_mean)
plot(capture_dat_plus$wind_mph_interpol,
     capture_dat_plus$CEWL_g_m2h_mean)
plot(capture_dat_plus$solar_rad_W_sqm_interpol,
     capture_dat_plus$CEWL_g_m2h_mean)
```

It looks like there are meaningful differences in CEWL across individuals/dates (probably confounded), and based on cloacal temp, capture temp, capture VPD, capture wind, and capture solar radiation.



# LMMs


## Osmolality


### Model Selection

Since there are large differences in osmolality by date, but we are interested in what's different among dates, rather than the capture date itself, we will include that as a random effect in the model.

```{r, osmolality model 1}
osml_mod1 <- lme4::lmer(data = capture_dat_plus,
                          # response variable
                          osmolality_mmol_kg_mean ~ 
                          # body size
                          mass_g + SVL_mm + SMI +
                          # blood sample traits
                          hemolyzed + hematocrit_percent + 
                          # weather at the time of capture
                          temp_C_interpol * VPD_kPa_int +
                          wind_mph_interpol + solar_rad_W_sqm_interpol +
                          # random effect
                          (1|capture_date)) 
summary(osml_mod1)
drop1(osml_mod1)
```

The model would improve the most (based on lower AIC) if we drop hematocrit.

```{r, osmolality model 2}
osml_mod2 <- lme4::lmer(data = capture_dat_plus,
                          # response variable
                          osmolality_mmol_kg_mean ~ 
                          # body size
                          mass_g + SVL_mm + SMI +
                          # blood sample traits
                          hemolyzed + 
                          # weather at the time of capture
                          temp_C_interpol * VPD_kPa_int +
                          wind_mph_interpol + solar_rad_W_sqm_interpol +
                          # random effect
                          (1|capture_date)) 
summary(osml_mod2)
drop1(osml_mod2)

# compare to full model
anova(osml_mod1, osml_mod2)
```

Next we can drop the interaction between temperature and VPD.

```{r, osmolality model 3}
osml_mod3 <- lme4::lmer(data = capture_dat_plus,
                          # response variable
                          osmolality_mmol_kg_mean ~ 
                          # body size
                          mass_g + SVL_mm + SMI +
                          # blood
                          hemolyzed +
                          # weather at the time of capture
                          temp_C_interpol + VPD_kPa_int +
                          wind_mph_interpol + solar_rad_W_sqm_interpol +
                          # random effect
                          (1|capture_date)) 
summary(osml_mod3)
drop1(osml_mod3)

# compare to previous model
anova(osml_mod2, osml_mod3)
```


Drop wind.

```{r, osmolality model 4}
osml_mod4 <- lme4::lmer(data = capture_dat_plus,
                          # response variable
                          osmolality_mmol_kg_mean ~ 
                          # body size
                          mass_g + SVL_mm + SMI +
                          # blood
                          hemolyzed +
                          # weather at the time of capture
                          temp_C_interpol + VPD_kPa_int +
                          solar_rad_W_sqm_interpol +
                          # random effect
                          (1|capture_date)) 
summary(osml_mod4)
drop1(osml_mod4)

# compare to previous model
anova(osml_mod3, osml_mod4)
```

Next drop mass, SMI, and whether a sample is hemolyzed.

```{r, osmolality model 5}
osml_mod5 <- lme4::lmer(data = capture_dat_plus,
                          # response variable
                          osmolality_mmol_kg_mean ~ 
                          # body size
                          SVL_mm + 
                          # weather at the time of capture
                          temp_C_interpol + VPD_kPa_int +
                          solar_rad_W_sqm_interpol +
                          # random effect
                          (1|capture_date)) 
summary(osml_mod5)
drop1(osml_mod5)

# compare to previous model
anova(osml_mod4, osml_mod5)
```

Drop temperature.

```{r, osmolality model 6}
osml_mod6 <- lme4::lmer(data = capture_dat_plus,
                          # response variable
                          osmolality_mmol_kg_mean ~ 
                          # body size
                          SVL_mm + 
                          # weather at the time of capture
                          VPD_kPa_int +
                          solar_rad_W_sqm_interpol +
                          # random effect
                          (1|capture_date)) 
summary(osml_mod6)
drop1(osml_mod6)

# compare to previous model
anova(osml_mod5, osml_mod6)
```

Drop VPD.

```{r, osmolality model 7}
osml_mod7 <- lme4::lmer(data = capture_dat_plus,
                          # response variable
                          osmolality_mmol_kg_mean ~ 
                          # body size
                          SVL_mm + 
                          # weather at the time of capture
                          solar_rad_W_sqm_interpol +
                          # random effect
                          (1|capture_date)) 
summary(osml_mod7)
drop1(osml_mod7)

# compare to previous model
anova(osml_mod6, osml_mod7)
```

```{r}

```





We do not decrease our predictive power significantly by dropping SMI, so we will consider the reduced model (2) to be better than the full (1).

Check whether to continue dropping terms:

```{r}
drop1(hydrat_mod2)
```

Dropping the current predictors will not improve AIC any more than its current value, so hydrat_mod2 is the best model to predict osmolality.


### Best Model

```{r}
# save model 2 summary object
osml_best_mod <- broom.mixed::tidy(hydrat_mod2)
# export 
write.csv(osml_best_mod, "./best models/osml_best_mod_vals.csv")
```


### Check LM Assumptions (Hydration Model)

First, get residuals:

```{r}
res_hydrat_mod <- hydrat_mod_dat %>%
  mutate(y_hat = predict(hydrat_mod2),
         e = residuals(hydrat_mod2))
```


Linearity and Equal Variance

Is the function **linear**? Is there **equal** variance of the residuals? The residuals should be homoskedactic relative to y_hat (or x). We don't care if there is a relationship between the residuals ~ dependent variable (actual y).

Plotting residuals shows us whether the data meets linearity and equal variance assumptions:

```{r}
ggplot(data = res_hydrat_mod, aes(x = y_hat, y = e)) +
  geom_point() + 
  theme_classic() + 
  xlab("predicted y (y-hat)") +
  ylab("residuals (e)") +
  ggtitle("Hydration Model 5") +
  geom_hline(yintercept = 0)
```

It looks pretty evenly distributed. No clear patterning, so linearity and equal error variance should be satisfied.

Brown-Forsythe test to statistically check equal variance:

H0: normally distributed (non-sig test is GOOD)
HA: NOT normally distributed (reject nul == assumption not satisfied)

```{r}
# need to create the right data & format first
bf_data_temp <- res_hydrat_mod %>%
  dplyr::filter(complete.cases(temp_C_interpol)) %>%
  dplyr::mutate(middle = median(temp_C_interpol),
                side = temp_C_interpol > middle)
bf_data_temp$side <- as.factor(bf_data_temp$side)

# now run test
bf.test(formula = e ~ side, # y~x
        data = bf_data_temp, # dataframe
        alpha = 0.05, # default 0.05
        na.rm = TRUE, # remove missing data before running?
        verbose = TRUE # print output to console?
        )

# need to create the right data & format first
bf_data_abshum <- res_hydrat_mod %>%
  dplyr::filter(complete.cases(abs_humidity_g_m3_interpol)) %>%
  dplyr::mutate(middle = median(abs_humidity_g_m3_interpol),
                side = abs_humidity_g_m3_interpol > middle)
bf_data_abshum$side <- as.factor(bf_data_abshum$side)

# now run test
bf.test(formula = e ~ side, # y~x
        data = bf_data_abshum, # dataframe
        alpha = 0.05, # default 0.05
        na.rm = TRUE, # remove missing data before running?
        verbose = TRUE # print output to console?
        )
```

Equal variance is satisfied.


Now check normality. Is the distribution of residuals **normal**?

use Shapiro-Wilk normality test:
H0: data is NOT significantly different from normal distribution
HA: data IS significantly different from normal distribution

```{r}
simple.eda(res_hydrat_mod$e)
shapiro.test(res_hydrat_mod$e)
```

Normality is satisfied.


### Conclusion

hydrat_mod2 is the best model to predict osmolality, and the model satisfies all linear regression assumptions.



## CEWL

Based on the simple linear models and figures above, CEWL should be predicted by:
- body region
- cloacal temperature at measurement
- capture temperature, absolute humidity, wind speed, and solar radiation
- ambient temperature during measurement
- SVL and mass
- hold time (time between capture vs measurement)
- individual ID (as a random effect)

Prep dataframe for models:

```{r}
CEWL_mod_dat <- CEWL_data_full %>% 
  # select variables of interest
  dplyr::select(date,
                hold_time,
                individual_ID,
                mass_g,
                SVL_mm, 
                TEWL_g_m2h,
                region,
                cloacal_temp_C,
                temp_C_interpol,
                abs_humidity_g_m3_interpol,
                Wind_mph_interpol,
                Solar_rad_Wm2_interpol,
                ambient_temp_C
                ) %>%
  dplyr::filter(complete.cases(.)) # removes 69 observations
```


### Multicollinearity

Check for multicollinearity among independent variables:

```{r}
CEWL_mod_dat %>% 
  # get rid of dependent variable
  dplyr::select(-TEWL_g_m2h, individual_ID) %>%
  # multicollinearity plot
  pairs(.)

# also make another plot with r-sq values
# non-numeric variables don't work for this
CEWL_mod_dat %>% 
  # select variables of interest
  dplyr::select(-TEWL_g_m2h, -date, -region, -individual_ID) %>% 
  # multicollinearity plot
  chart.Correlation(., histogram = F, pch = 19)
```

Mass and SVL are very collinear variables that should not be used in combination. Cloacal temp and hold time are pretty collinear, which makes sense; as we held them, they got cooler because they were inside and not basking. Individual ID and absolute humidity are also pretty collinear, but it's less intuitive. Temperature and solar radiation, as well as humidity and solar radiation, are each collinear pairs. We will use model selection to figure out which variable from each collinear pair is better to include in the model.



### Models & Selection

This is the full model with every potential variable and interaction baed on figures and SLR.

```{r}
# model 1
CEWL_mod1 <- lme4::lmer(data = CEWL_mod_dat,
                        TEWL_g_m2h ~
                         region * (mass_g + ambient_temp_C +
                                     temp_C_interpol +
                                     abs_humidity_g_m3_interpol) +
                         hold_time + SVL_mm +
                         cloacal_temp_C +
                         temp_C_interpol:abs_humidity_g_m3_interpol +
                         Wind_mph_interpol +
                         Solar_rad_Wm2_interpol + 
                         (1|individual_ID)) 
summary(CEWL_mod1)
```


Check which variables to drop:

```{r}
drop1(CEWL_mod1)
```

Based on AIC, dropping SVL, hold time, temp, humidity, wind speed, region:ambient_temp_C, and temp_C_interpol:abs_humidity_g_m3_interpol would result in a better model. 

Start with region:ambient_temp_C and temp_C_interpol:abs_humidity_g_m3_interpol interactions:

```{r}
# model 2
CEWL_mod2 <- lme4::lmer(data = CEWL_mod_dat,
                        TEWL_g_m2h ~
                         region * (mass_g +
                                     temp_C_interpol +
                                     abs_humidity_g_m3_interpol) +
                         hold_time + SVL_mm +
                         cloacal_temp_C +
                         Wind_mph_interpol +
                         Solar_rad_Wm2_interpol + 
                         (1|individual_ID)) 
summary(CEWL_mod2)

# compare
anova(CEWL_mod2, CEWL_mod1)
```

AIC improved somewhat and we do not lose a significant amount of predictive power, so the reduced model is better. Continue dropping...

Check drop terms again:

```{r}
drop1(CEWL_mod2)
```

Hold time, SVL, and wind should still be deleted.

```{r}
# model 3
CEWL_mod3 <- lme4::lmer(data = CEWL_mod_dat,
                        TEWL_g_m2h ~
                         region * (mass_g +
                                     temp_C_interpol +
                                     abs_humidity_g_m3_interpol) +
                         cloacal_temp_C +
                         Solar_rad_Wm2_interpol + 
                         (1|individual_ID)) 
summary(CEWL_mod3)

# compare
anova(CEWL_mod3, CEWL_mod1)
anova(CEWL_mod3, CEWL_mod2)
```

Once again, the AIC is slightly lower, and our model fit is not significantly worse by going to model 3, so the reduced model is better.

Check drop terms again to make sure nothing else could potentially be removed:

```{r}
drop1(CEWL_mod3)
```

Check whether removing Solar_rad_Wm2_interpol is okay:

```{r}
# model 4
CEWL_mod4 <- lme4::lmer(data = CEWL_mod_dat,
                        TEWL_g_m2h ~
                         region * (mass_g +
                                     temp_C_interpol +
                                     abs_humidity_g_m3_interpol) +
                         cloacal_temp_C +
                         (1|individual_ID)) 
summary(CEWL_mod4)

# compare
anova(CEWL_mod4, CEWL_mod1)
anova(CEWL_mod4, CEWL_mod3)
```

We do lose significant predictive power when we go from model 3 to 4... So model 3 is the best model to predict CEWL.

Since we dropped a lot of variables, I want to go back and make sure to use as much data as possible in the final model, so I can add back in observations with missing values for variables no longer included in the reduced model.

```{r}
# filter
CEWL_mod_dat2 <- CEWL_data_full %>% 
  # select variables of interest
  dplyr::select(individual_ID,
                mass_g,
                TEWL_g_m2h,
                region,
                cloacal_temp_C,
                temp_C_interpol,
                abs_humidity_g_m3_interpol,
                Solar_rad_Wm2_interpol,
                ) %>%
  dplyr::filter(complete.cases(.)) # able to have 5 more observations

# redo best model



# model 3
CEWL_mod3_adj <- lmerTest::lmer(data = CEWL_mod_dat2,
                        TEWL_g_m2h ~
                         region * (mass_g +
                                     temp_C_interpol +
                                     abs_humidity_g_m3_interpol) +
                         cloacal_temp_C +
                         Solar_rad_Wm2_interpol + 
                         (1|individual_ID)) 
summary(CEWL_mod3_adj)
```



### Best Model

The best model is CEWL predicted by: body region and its interaction with mass and capture temp and humidity, cloacal temperature, solar radiation at capture time, and individual ID as a random effect.

```{r}
# save best model info
CEWL_best_mod <- broom.mixed::tidy(CEWL_mod3_adj)
# export 
#write.csv(CEWL_best_mod, "./best models/CEWL_best_mod_vals.csv")
```



### Check LM Assumptions

First, get residuals:

```{r}
CEWL_mod_res <- CEWL_mod_dat2 %>%
  mutate(y_hat = predict(CEWL_mod3_adj),
         e = residuals(CEWL_mod3_adj))
```


Linearity and Equal Variance

Is the function **linear**? Is there **equal** variance of the residuals? The residuals should be homoskedactic relative to y_hat (or x). We don't care if there is a relationship between the residuals ~ dependent variable (actual y).

Plotting residuals shows us whether the data meets linearity and equal variance assumptions:

```{r}
ggplot(data = CEWL_mod_res, aes(x = y_hat, y = e)) +
  geom_point() + 
  theme_classic() + 
  xlab("predicted y (y-hat)") +
  ylab("residuals (e)") +
  ggtitle("CEWL Model Residuals") +
  geom_hline(yintercept = 0)
```

It's definitely making a fan shape. :(

Brown-Forsythe test to statistically check equal variance, for each continuous predictor variable:

H0: normally distributed (non-sig test is GOOD)
HA: NOT normally distributed (reject nul == assumption not satisfied)


```{r}
# need to create the right data & format first
bf_data_CEWL <- CEWL_mod_res %>%
  dplyr::mutate(middle_mass = median(mass_g), # mass
                side_mass = as.factor(mass_g > middle_mass),
                # solar radiation
                middle_sorad = median(Solar_rad_Wm2_interpol),
                side_sorad = as.factor(Solar_rad_Wm2_interpol > middle_sorad), 
                # temperature
                middle_temp = median(temp_C_interpol),
                side_temp = as.factor(temp_C_interpol > middle_temp),
                # absolute humidity
                middle_absh = median(abs_humidity_g_m3_interpol),
                side_absh = as.factor(abs_humidity_g_m3_interpol > middle_absh),
                middle_ct = median(cloacal_temp_C),
                side_ct = as.factor(cloacal_temp_C > middle_ct)
                )


# now run test
bf.test(formula = e ~ side_absh, # y~x
        data = bf_data_CEWL, # dataframe
        alpha = 0.05, # default 0.05
        na.rm = TRUE, # remove missing data before running?
        verbose = TRUE # print output to console?
        )
bf.test(formula = e ~ side_temp, # y~x
        data = bf_data_CEWL, # dataframe
        alpha = 0.05, # default 0.05
        na.rm = TRUE, # remove missing data before running?
        verbose = TRUE # print output to console?
        )
bf.test(formula = e ~ side_sorad, # y~x
        data = bf_data_CEWL, # dataframe
        alpha = 0.05, # default 0.05
        na.rm = TRUE, # remove missing data before running?
        verbose = TRUE # print output to console?
        )
bf.test(formula = e ~ side_ct, # y~x
        data = bf_data_CEWL, # dataframe
        alpha = 0.05, # default 0.05
        na.rm = TRUE, # remove missing data before running?
        verbose = TRUE # print output to console?
        )
bf.test(formula = e ~ side_mass, # y~x
        data = bf_data_CEWL, # dataframe
        alpha = 0.05, # default 0.05
        na.rm = TRUE, # remove missing data before running?
        verbose = TRUE # print output to console?
        )
```

Equal variance is satisfied for all 5 continuous predictor variables.


Now check normality. Is the distribution of residuals **normal**?

use Shapiro-Wilk normality test:
H0: data is NOT significantly different from normal distribution
HA: data IS significantly different from normal distribution

```{r}
simple.eda(CEWL_mod_res$e)
shapiro.test(CEWL_mod_res$e)
```

not normal!


### Test Transformations 

Can I improve satisfaction of LM assumptions by transforming the dependent variable?

```{r}
# sqrt(TEWL)
CEWL_data_full %>%
  ggplot(., aes(x = sqrt(TEWL_g_m2h))) +
  geom_histogram(color = "black", fill="steelblue", bins=50) + 
  theme_classic() +
  xlab("sqrt(CEWL)") + 
  ylab("Count") + 
  facet_wrap(~region)

# log(temperature)
CEWL_data_full %>%
  ggplot(., aes(x = log(TEWL_g_m2h))) +
  geom_histogram(color = "black", fill="steelblue", bins=50) + 
  theme_classic() +
  xlab("LOG(CEWL)") + 
  ylab("Count") + 
  facet_wrap(~region)
```


Log transforming seems to be pretty effective across body regions.



### Transform & Re-Model

I will log-transform CEWL and see whether it makes the models satisfy LMM assumptions better.

Run CEWL model 4 with log-transformed CEWL:

```{r}
summary(CEWL_mod_dat2)
# log-transformed model 3
CEWL_mod3_t <- lmerTest::lmer(data = CEWL_mod_dat2,
                          log(TEWL_g_m2h) ~
                            region * (mass_g +
                                     temp_C_interpol +
                                     abs_humidity_g_m3_interpol) +
                            cloacal_temp_C + Solar_rad_Wm2_interpol +
                            (1|individual_ID)) 
summary(CEWL_mod3_t)

# compare
anova(CEWL_mod3_t, CEWL_mod3_adj)
```



### Re-Check Assumptions (transformed model 3)

First, get residuals:

```{r}
CEWL_t_mod_res <- CEWL_mod_dat2 %>%
  mutate(y_hat = predict(CEWL_mod3_t),
         e = residuals(CEWL_mod3_t))
```


Linearity and Equal Variance

Is the function **linear**? Is there **equal** variance of the residuals? The residuals should be homoskedactic relative to y_hat (or x). We don't care if there is a relationship between the residuals ~ dependent variable (actual y).

Plotting residuals shows us whether the data meets linearity and equal variance assumptions:

```{r}
ggplot(data = CEWL_t_mod_res, aes(x = y_hat, y = e)) +
  geom_point() + 
  theme_classic() + 
  xlab("predicted y (y-hat)") +
  ylab("residuals (e)") +
  ggtitle("CEWL Model 13 Residuals") +
  geom_hline(yintercept = 0)
```

It looks much much better. :) Equal error variance doesn't look perfect, but there's no more fan shape.

Brown-Forsythe test to statistically check equal variance:

H0: normally distributed (non-sig test is GOOD)
HA: NOT normally distributed (reject nul == assumption not satisfied)

```{r}
# need to create the right data & format first
bf_data_CEWL_t <- CEWL_t_mod_res %>%
  dplyr::mutate(middle_mass = median(mass_g), # mass
                side_mass = as.factor(mass_g > middle_mass),
                # solar radiation
                middle_sorad = median(Solar_rad_Wm2_interpol),
                side_sorad = as.factor(Solar_rad_Wm2_interpol > middle_sorad), 
                # temperature
                middle_temp = median(temp_C_interpol),
                side_temp = as.factor(temp_C_interpol > middle_temp),
                # absolute humidity
                middle_absh = median(abs_humidity_g_m3_interpol),
                side_absh = as.factor(abs_humidity_g_m3_interpol > middle_absh),
                middle_ct = median(cloacal_temp_C),
                side_ct = as.factor(cloacal_temp_C > middle_ct)
                )


# now run test
bf.test(formula = e ~ side_absh, # y~x
        data = bf_data_CEWL_t, # dataframe
        alpha = 0.05, # default 0.05
        na.rm = TRUE, # remove missing data before running?
        verbose = TRUE # print output to console?
        )
bf.test(formula = e ~ side_temp, # y~x
        data = bf_data_CEWL_t, # dataframe
        alpha = 0.05, # default 0.05
        na.rm = TRUE, # remove missing data before running?
        verbose = TRUE # print output to console?
        )
bf.test(formula = e ~ side_sorad, # y~x
        data = bf_data_CEWL_t, # dataframe
        alpha = 0.05, # default 0.05
        na.rm = TRUE, # remove missing data before running?
        verbose = TRUE # print output to console?
        )
bf.test(formula = e ~ side_ct, # y~x
        data = bf_data_CEWL_t, # dataframe
        alpha = 0.05, # default 0.05
        na.rm = TRUE, # remove missing data before running?
        verbose = TRUE # print output to console?
        )
bf.test(formula = e ~ side_mass, # y~x
        data = bf_data_CEWL_t, # dataframe
        alpha = 0.05, # default 0.05
        na.rm = TRUE, # remove missing data before running?
        verbose = TRUE # print output to console?
        )
```

Equal variance is still satisfied for all continuous predictor variables.


Now check normality. Is the distribution of residuals **normal**?

use Shapiro-Wilk normality test:
H0: data is NOT significantly different from normal distribution
HA: data IS significantly different from normal distribution

```{r}
simple.eda(CEWL_t_mod_res$e)
shapiro.test(CEWL_t_mod_res$e)
```

Still not statistically normal... but the distribution looks a lot better.


### Conclusion

The best CEWL model should use log-transformed CEWL because this greatly improves the model based on AIC and it allows the model to satisfy the linearity assumption of LMM. 

```{r}
# save log model 3 summary object
CEWL_best_t_mod <- broom.mixed::tidy(CEWL_mod3_t)
# export 
write.csv(CEWL_best_t_mod, "./best models/CEWL_best_mod_t_vals.csv")
```





# What to Present in the Paper

- figures (exported)
- hct SLR
- best osml mod (transformed?)
- best CEWL mod (CEWL transformed)

